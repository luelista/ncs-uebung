5.1)
a) Eigentlich wird durch den three-way-handshake die Verbindung immer zuverlässig beendet, da die einzelnen Nachrichten einfach immer so lange geschickt werden, bis eine Bestätigung der Gegenseite empfangen wurde.
Der einzige Fall, in dem ein three-way-handshake nicht zum gewünschten Ergebnis führt, ist der, in dem man die Senderichtung schließen möchte, aber weiterhin Pakete von der Gegenseite empfangen möchte. Dies ist durch einen three-way-handshake nicht möglich, da hier die Verbindung sobald sie von einer Seite geschlossen wurde auch immer von der Gegenseite geschlossen wird.
b) 1. Als Ergänzung zum three-way-handshake wäre es auch möglich, den zweiten Schritt des Protokolls in 2 Nachrichten aufzuteilen, also Ack und die Nachricht zum Beenden der Verbindung zu trennen (siehe Grafik 1, quelle Wikipedia).
2. Es wäre außerdem möglich, die Verbindung zu trennen, ohne überhaupt eine Nachricht an die Gegenseite zu schicken. Konkret würde das bedeuten, dass man nach Trennen der Verbindung keine Pakete der Gegenseite mehr akzeptieren würde. Die Gegenseite würde dann nach einer bestimmten Zeit ohne Antwort auf die eigenen Nachrichten die Verbindung ebenfalls beenden (timeout).
c) B würde nicht merken, dass die Connection Confirmation (CC) nie bei A angekommen ist, davon ausgehen, dass nun eine Verbindung aufgebaut ist und auf die Übertragung von Daten warten.
2)
    TCP beendet Verbindungen, in dem von A ein Paket gesendet wird, welches das FIN Bit im TCP Header gesetzt hat. Der Erhalt dieses Paketes wird von B durch eine ACK Nachricht mit entsprechender Sequenznummer sichergestellt.
    Daraufhin beendet B seine Verbindung ebenfalls durch eine Nachricht mt FIN Bit. Auch dies wird durch eine ACK Nachricht bestätigt.
    Nach senden des letzten ACKs wechseln die Clients in einen vorrübergehenden Wartezustand in dem alle ankommenden Nachrichten verworfen werden. So ist sichergestellt, dass verspätete Nachrichten nicht falsch interpretiert werden und Verbindungen zuverlässig beendet werden.
3)
    1: Zu Zeitpunkt t1 geht B davon aus, dass eine Verbindung zu A aufgebaut wurde, obwohl keine gültige Anfrage von A vorlag.
    Die Verletzung des Protokolls liegt hier im zweiten Schritt. B geht davon aus, dass ein gültiges ConnectRequest von A über Referenz X vorliegt. Es handelt sich allerdings um ein Duplikat eines älteren Requests, woraus geschlossen werden kann, dass offensichtlich vorher eine Verbindung zu A über X vorlag. B sendet nun eine ConnectConfirmation mit der eigenen Referenz Y. Dies ist nicht zulässig, da wir uns offensichtlich noch in dem Zeitintervall befinden, in dem die Referenz Y gesperrt ist. Dies wird dadurch deutlich, dass das doppelte CR(X) noch nicht aufgrund seines Alters verworfen wurde. B dürfte demnach nur eine ConnectConfirmation mit einer anderen eigenen Referenz als Y senden, was Fehler verhindern würde.
    2: Zu Zeitpunkt t2 geht A davon aus, dass eine gültige Verbindung zu B aufgebaut wurde
    Hier ist schon der erste Schritt eine Verletzung des Protokolls. A versucht über die Referenz X eine Verbindung zu B aufzubauen. Da kurz darauf eine doppelte ConnectConfirmation CC(Z,X) eintrifft, war die Referenz X in diesem Zeitintervall offensichtlich noch gesperrt und hätte nicht wieder vergeben werden dürfen. Wäre die Sperrzeit von X schon vorbei, so wäre auch das veraltete CC(Z,X) schon aufgrund seines Alters verworfen worden.
