\documentclass[a4paper,
			llpt,
			solution,
			accentcolor=tud2d,
			colorbacktitle
			]
			{tudexercise}

\usepackage[utf8]{inputenc}
\usepackage[ngerman]{babel}
\usepackage{paralist}
\usepackage{amsmath}

\title{Lösungsvorschlag zur zweiten Hausübung}
\subtitle{Einführung in Net Centric Systems und \LaTeX, Sommersemester 2015}
\subsubtitle{Max Weller, Julian Haas, Stefan Pilot}

\newcommand{\MiBs}{\frac{\mathrm{MiB}}{\mathrm{s}}}
\begin{document}

\maketitle
\section{}


%2.1.txt
\begin{enumerate}

\item
Normalerweise werden bei einem verbindungsorientierten Dienst die Pakete in der Reihenfolge zugestellt, in der sie gesendet wurden. Falls die Pakete in der falschen Reihenfolge beim Empfänger ankommen, werden sie entweder verworfen und später neu angefordert, oder aber gepuffert und in der richtigen Reihenfolge weitergereicht.
Es gibt allerdings Ausnahmen, z.B. das TCP-Urgent-Flag, welches den Empfänger veranlasst, ein Paket vorzuziehen.

\item
Connectionless:
\begin{itemize}
\item IP-Telefonie
\item Live-TV-Streaming
(es ist wichtig, dass Pakete mit möglichst geringer Latenz ankommen. Verloren gegangene Pakete sollten nicht wiederholt werden.)
\end{itemize}
Connection-oriented:
\begin{itemize}
\item Dateidownload (z.B. FTP)
(Daten müssen in der richtigen Reihenfolge und vollständig ankommen)
\item Web (HTTP)
(Webseiten und Bilder sollten in korrekter Reihenfolge übertragen werden)
\end{itemize}
\end{enumerate}
\section{}
\begin{enumerate}
\item
Während des 200ms langen Burst mit Datenrate $20\MiBs$ empfängt der token bucket 4MiB Daten: 

\begin{align*}
\text{t}_\text{burst}  \cdot \text{R}_\text{max} &= \text{Datenmenge Burst}
\\
200\mathrm{ms} \cdot 20\MiBs &= \mathrm{4MiB}
\end{align*}


Für t1 = 125ms kann der token bucket die empfangenen Daten mit $\mathrm{R}_{\mathrm{max}} = 20\MiBs$, weiterleiten:
\begin{align*}
\mathrm{B} + \mathrm{R}\cdot\mathrm{t}_1 &= \mathrm{R}_ {\mathrm{max}} \cdot t_1
\\
t_1 &= 0.125\mathrm{s}
\end{align*}

Nach diesen 125ms verbleiben noch 1.5MiB an zu sendenden Daten:
$$4\mathrm{MiB} - \left(0.125\mathrm{s} \cdot 20\MiBs\right) = 1.5 \mathrm{MiB}$$

Diese 1.5MiB werden dann mit der Rate R = $4\MiBs
$
% = 0.004 \frac{\mathrm{MiB}}{\mathrm{ms}}$
übertragen. Das dauert 375ms:
$$
\frac{1.5 \mathrm{MiB}}{ 4 \MiBs} = 375\mathrm{ms}
$$
Der Graph sieht also so aus:
$$\text{HIER GRAPH EINFÜGEN}$$
Die bis zur vollen Sekunde verbleibenden 500ms reichen, bis sich der token bucket wieder gefüllt hat: 
$$
4\MiBs \cdot 500\mathrm{ms} = 2\mathrm{MiB} = \mathrm{B}
$$
\item
Während der token bucket Daten mit $20\MiBs$ versendet, füllt sich der leaky bucket mit einer Rate von
$$
20 \MiBs - 10\MiBs = 10\MiBs
$$
Nach den 125ms sind
$$
10\MiBs  \cdot 125\mathrm{ms} = 1.25 \mathrm{MiB}
$$ im leaky bucket.
In den nächsten 375ms, in denen der token bucket mit $4\MiBs$ verschickt, leert sich der leaky bucket mit einer Rate von
$$
4\MiBs - 10\MiBs = -6 \MiBs
$$
Die gespeicherten 1.25MiB Daten brauchen
$$
\frac{1.25\mathrm{MiB}}{6\MiBs} = 208.33\mathrm{ms}
$$
um den leaky bucket wieder zu verlassen.
\\\\
Antwort: Der leaky bucket verliert keine Daten.
\end{enumerate}

\section{}
\section{}


\end{document}


